# 单片机调试找错

- 单片机开发，不仅涉及软件开发，还需要硬件调试。两者纠缠，常常出错。

- 导致现象可能和预期不一样。

- 导致同一个现象，往往对应很多不同的结果，所以要排查。

- 排查大体上从硬件到软件，从整体到局部，如果没有找到错误，则倒查，反复查找。

- 以单片机-红外模块-LED为例，红外检测则单片机输出高电平控制LED灯点亮，红外未检测则单片机控制电平低使得LED灭。

- 本内容默认读者拥有一定的简单基础，能完成烧录、编程等基础操作。

- 以控制变量法为主，不要主观相信任何没有实际测试的部分，不要过分相信队友。

- 不要发懒。

# 1. 问题复现

- 稳定复现问题才能正确的对问题进行定位、解决以及验证。
  
- 一般来说，越容易复现的问题越容易解决。

## 1.1 模拟复现条件

- 有的问题存在于特定的条件下，需要模拟出现问题的条件才可复现。

- 问题难以复现，可以提高相关任务执行频率，可以多套设备同时进行测试。

- 对于依赖外部输入的条件，如果条件比较复杂难以模拟可以考虑程序里预设直接进入对应状态。


# 2. 排查顺序

## 2.1 硬件

- 排除设计和加工的工艺错误。主要排除错误包括错线、开路和短路。仔细查看原理图。特别注意电源系统的检查，以防止电源短路和极性错误，并重点检查系统总线(地址总线、数据总线和控制总线)是否相互短路或与其他信号线短路。如有必要，使用数字万用表的短路测试功能可以缩短故障排除时间。

- 烧录单片机厂家的测试例程，或者以板载硬件LED为测试内容，以此确定单片机没问题。不要死脑筋，串口出错了一直试LED有没有错。

- 测试模块是否有问题。两个模块：红外检测模块和外接LED都测试，通过上电，保证其功能能正常完成，其正常完成以指示灯亮为标志。不要死脑筋，比如超声波模块一直得不到距离或者乱码，但是看了指示灯就说没问题。起码也应该接串口看看到底硬件是否出错。

- 元器件在购买时良好，但是烧坏也正常。所以之前功能正常，但是现在坏了，无法观察到现象。

- 杜邦线是否有问题。之前出过类似问题，因为瞬间大电流内部烧断，但是外貌看起来正常。

- 虚焊问题导致接触有问题，杜邦线接线松垮，导致接触有问题。如有必要，热熔胶粘住。

- 元器件、单片机，只要有电，全部共地，不共地没反应。

- 软件设置GPIO端口，是否与物理上的硬件接线口对应。

- 电压/电流不足，导致不能完成功能，电压够了不代表电流够，不同的电压甚至会出现相反的结果。
	- 之前有过情况，摄像头供电电压足够，但是电流不够导致不断重启；
 	- 电机上电之后转一下不转，电流电压不够了。	

- 电机舵机单独供电，不然带不动。

- 电机舵机直接接单片机，启动具有反电动势，可能直接烧了板子，表面上也看不出来。

## 2.2 软件


- 不熟悉C语言，过于初级，仅简单提及特殊情况。
```c
//main.c文件中
main()
{
	while(1)
	{
		function();
	}	
}
//没有while(1)的去情况下运行到最后一行的时候，会自动跳转到main函数的第一行，就造成了main()函数的返回,会导致汇编语言处跳到不可预期的地方，造成跑飞。
```

- 报错导致不生成hex文件，过于初级，不提及。

- 已经使用新项目文件，但是因为烧录软件一直没关，一直烧录旧文件，过于初级，不提及。

- 烧录单片机厂家的测试例程，或者以板载硬件LED为测试内容，以此确定单片机没问题。

- 对照完成可使用代码，对比查看自己代码。

- 对照用户手册，查看是否理解错误。

- 跳转结构体定义，对照结构体，查看是否缺少语句。

- 使用项目内的find功能，查看是否无意识压到键盘多了内容。比如无意去掉了注释，无意加了注释，添加了含义冲突内容等。

```c
无意去掉了注释，或者添加注释：
预期：上电LED就亮。
在main.c中，
main()
{
  //LED0=0；//置高
  LED0=1；//置低
}
```

```c
添加了含义冲突内容
预期：上电LED就亮。
在main.c中，
main()
{
  LED0=0；//置高
}
但是在led.c中，led_init()函数中，
void led_init(void)
{
  ...
  GPIO_ResetBits(GPIO_LED, GPIO_Pin_LED);  //置低
}
前后不同文件冲突。
```

- 使用手册，明确含义。比如有的厂家置0为高电平，有的厂家置1为高电平。
```c
LED1 = 1;  //A厂亮灯语句

LED1 = 0;  //B厂亮灯语句
```

- 去掉限制条件，直接查看内容。
```c
原本：
if(situation)
{
  funtion();
}

现在：
  funtion();
```

- 考虑数据为0的特殊情况，考虑数据初始化的特殊情况，考虑数据越界之后的特殊情况。
```c
//之前因为没有考虑dis==0，一直导致逻辑和现象不相符合。
//因为距离过大之后，并不显示范围内的最大值max_value，而是初始化值0。
dis = Ultra_Distance();
printf("Ultra_Distance:%d\r\n",dis);
if(dis)
{
	if(dis<10)
	{
		printf("1\r\n");
		GPIO_SetBits(GPIOB,GPIO_Pin_9);
	}
	else
	{
		printf("0\r\n");
		GPIO_ResetBits(GPIOB,GPIO_Pin_9);	
		delay_ms(500);
	}
}
```
```c
//初始化并不代表为0,初始化就是初始化。
int state;
if(state)
{
	function();
}
```
```c
//越界要考虑好。
//比如单片机数值过大，导致从负数跳成正数。
//此处无代码
```

- 自上而下，使用led功能作为标志位，控制变量，每一句，每一个函数，函数开始，函数出口，函数结束，排查错误位置。

- 自上而下，使用USART功能作为标志位，控制变量，每一句，每一个函数，函数开始，函数出口，函数结束，排查错误位置。

- 自上而下，使用LOG功能，控制变量，每一句，每一个函数，函数开始，函数出口，函数结束，排查错误位置。

- 自上而下，使用OLED/LCD功能作为标志位，控制变量，每一句，每一个函数，函数开始，函数出口，函数结束，排查错误位置。

- 版本回退，不要告诉我你的文件每次更新之后不备份。使用旧版本查看是否能完成功能。确定是否是增加修改的代码出了问题。

- 定时器回调函数内容过多停留时间过长导致跑飞。

- 有if没有else导致代码跑飞。
```c
//dis < 0 就是要处理的特殊情况，不代表对此之外的情况就可以不考虑。
while(1)
{
	dis = Ultra_Distance();
	printf("Ultra_Distance:%d\r\n",dis);
	if(dis < 10)
	{
		function();
	}
}
```

- 没有看门狗wdg导致跑飞但是不知道。

- 通信没有对上导致跑飞。

- 通信不设置帧头帧尾导致数据混乱，一般2个帧头即可。

- 截图截全，截全的意思就是你的屏幕有多大就尽量截多大，除非有不能被看的适当避开。

- 截图不如视频，视频要配讲解说明。










